<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>gqueue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ugfx_logo_doxygen.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">version 2.6</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('gqueue_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">gqueue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GQUEUE header file. </p>

<p>Definition in file <a class="el" href="gqueue_8h_source.html">gqueue.h</a>.</p>
</div>
<p><a href="gqueue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue item.  <a href="structgfx_queue_a_sync_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue.  <a href="structgfx_queue_a_sync.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_data_buffer.html">GDataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Data Buffer Queue.  <a href="struct_g_data_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialisation functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Initialise a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Whilst queues are normally FIFO, a GFX queue also supports push and pop operations. A pop operation is the same as normal get from the queue but a push places the item at the head of the queue instead of the tail (as a put would).</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:ga03a187ba5739f36530498f333145a913"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncInit</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="separator:ga03a187ba5739f36530498f333145a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b977df2892d59b7ffa0c63c629d6dd"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncInit</b> (gfxQueueGSync *pqueue)</td></tr>
<tr class="separator:ga14b977df2892d59b7ffa0c63c629d6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4651f6cb9c071ae66ac0a7363f1dce9f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncInit</b> (gfxQueueFSync *pqueue)</td></tr>
<tr class="separator:ga4651f6cb9c071ae66ac0a7363f1dce9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get an item from the head of the queue (and remove it from the queue).</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if the timeout expires before an item is available</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item. For ASync queues this parameter is not specified as TIME_IMMEDIATE is assumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:ga83033845f1cc4e859293f759d184ef24"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncGet</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="separator:ga83033845f1cc4e859293f759d184ef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2e0b2046bd34e2bdd77a7c178d0850"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncGetI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="separator:ga6e2e0b2046bd34e2bdd77a7c178d0850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb1a0982330c88386890f82cb94f714"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncGet</b> (gfxQueueGSync *pqueue, delaytime_t ms)</td></tr>
<tr class="separator:gaebb1a0982330c88386890f82cb94f714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae85084f1fd6fa64dd0433ed2d24957db"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncGetI</b> (gfxQueueGSync *pqueue)</td></tr>
<tr class="separator:gae85084f1fd6fa64dd0433ed2d24957db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee6d919291966b32b3b89682e09913f"><td class="memItemLeft" align="right" valign="top">
gfxQueueFSyncItem *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncGet</b> (gfxQueueFSync *pqueue, delaytime_t ms)</td></tr>
<tr class="separator:gafee6d919291966b32b3b89682e09913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Put() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Put an item on the end of the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be removed from the queue (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:ga001f294beec7a5a93bb386caded77b17"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPut</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga001f294beec7a5a93bb386caded77b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077fa0788a1c9e77de24b653b00bd822"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPutI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga077fa0788a1c9e77de24b653b00bd822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a1e2048cbb5d46ea00b97b62016f7a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPut</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga29a1e2048cbb5d46ea00b97b62016f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c698db99c16e5e17254e4bcd8686f3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPutI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga68c698db99c16e5e17254e4bcd8686f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e053eba0ca203f98896e3049eb6c34"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPut</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, delaytime_t ms)</td></tr>
<tr class="separator:ga99e053eba0ca203f98896e3049eb6c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Push() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Push an item into the start of the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be popped (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:ga89673f2d1210c10ff00ef6c4b5312900"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPush</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga89673f2d1210c10ff00ef6c4b5312900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa023f02f86039a81e2db96e777e3a991"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPushI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gaa023f02f86039a81e2db96e777e3a991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2415bb7b6e06dd5060133d306d5321"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPush</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga5a2415bb7b6e06dd5060133d306d5321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e545ee12d1caf3324029f196e2d21f9"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPushI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga4e545ee12d1caf3324029f196e2d21f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912bddea2951b911d67ee658ae6f5dea"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPush</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, delaytime_t ms)</td></tr>
<tr class="separator:ga912bddea2951b911d67ee658ae6f5dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Insert an item on the queue after the specified item.</p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pafter</td><td>A pointer to the queue item this new item must be inserted after. If NULL or pafter can't be found in the queue, it puts the new item at the end of the queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be removed from the queue (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gae63e497a256d0d1283ac7827fa3eb310"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncInsert</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:gae63e497a256d0d1283ac7827fa3eb310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45aadd51433be0253014497d94d50ff5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncInsertI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:ga45aadd51433be0253014497d94d50ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5ca470f46aec8cf41132a1e7374f1b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncInsert</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:ga0a5ca470f46aec8cf41132a1e7374f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d56974a55fd28495b2aefeaa318cd4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncInsertI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:ga00d56974a55fd28495b2aefeaa318cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b913366908bb4cf5d0853da6fec817"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncInsert</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter, delaytime_t ms)</td></tr>
<tr class="separator:gaf2b913366908bb4cf5d0853da6fec817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Remove() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Remove an item from the queue.</p>
<dl class="section note"><dt>Note</dt><dd>Removes the specified item from the queue where-ever it is in the queue</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the item isn't in the queue the routine just returns. </dd>
<dd>
If a process is waiting on the Put/Push operation for the item, that process will be signaled. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gacab8013b870b58e1a8a082fac8d06e1d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncRemove</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gacab8013b870b58e1a8a082fac8d06e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca02e905e708a7ad69471d97ca79d8b1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncRemoveI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gaca02e905e708a7ad69471d97ca79d8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d1a6b2b8f8e81801cd2e36405307fc"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncRemove</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga25d1a6b2b8f8e81801cd2e36405307fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4b7e2dabbf7b1c4486fc5155c0bfaa"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncRemoveI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:gaef4b7e2dabbf7b1c4486fc5155c0bfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a32b12810379e7282198ae224633b0"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncRemove</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem)</td></tr>
<tr class="separator:ga74a32b12810379e7282198ae224633b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">IsInQueue() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Is an item in the queue?</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the item is in the queue?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation may be expensive. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gae5402e7c7e959c59230bdc2650366089"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsIn</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gae5402e7c7e959c59230bdc2650366089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08afeb3550f1104ae87324e9b50bf96d"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsInI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga08afeb3550f1104ae87324e9b50bf96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5813e6e864d2d81ffa181f43f7fe961a"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsIn</b> (gfxQueueGSync *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga5813e6e864d2d81ffa181f43f7fe961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08147f2ad13a0e255a9a43c385274535"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsInI</b> (gfxQueueGSync *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga08147f2ad13a0e255a9a43c385274535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8557b49663b1020e119afa6ba9684f4a"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsIn</b> (gfxQueueFSync *pqueue, const gfxQueueFSyncItem *pitem)</td></tr>
<tr class="separator:ga8557b49663b1020e119afa6ba9684f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5c3b9170965008ff3cd15a9aa862fc"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsInI</b> (gfxQueueFSync *pqueue, const gfxQueueFSyncItem *pitem)</td></tr>
<tr class="separator:gafb5c3b9170965008ff3cd15a9aa862fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">BufferAlloc() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Allocate some buffers and put them on the free list</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE is it succeeded. FALSE on allocation failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of buffers to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size (in bytes) of each buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gaabc0607342c286aa4f6781c5c9998c7f"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferAlloc</b> (unsigned num, size_t size)</td></tr>
<tr class="separator:gaabc0607342c286aa4f6781c5c9998c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">BufferIsAvailable() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Is there one or more buffers currently available on the free list</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if there are buffers in the free list</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gaa687b976d39b1327bc4383292dbf9890"><td class="memItemLeft" align="right" valign="top">
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferIsAvailable</b> (void)</td></tr>
<tr class="separator:gaa687b976d39b1327bc4383292dbf9890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">BufferGet() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get a buffer from the free list</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_g_data_buffer.html" title="A Data Buffer Queue. ">GDataBuffer</a> pointer or NULL if the timeout is exceeded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maximum amount of time in milliseconds to wait for a buffer if one is not available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gaf854d111b80bc966929ce487d087c14f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferGet</b> (delaytime_t ms)</td></tr>
<tr class="separator:gaf854d111b80bc966929ce487d087c14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568fed962fb35a16dc3ebbdeb829aba8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferGetI</b> (void)</td></tr>
<tr class="separator:ga568fed962fb35a16dc3ebbdeb829aba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">BufferRelease() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Release a buffer back to the free list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The buffer to put (back) on the free-list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call should be used to return any buffers that were taken from the free-list once they have been finished with. It can also be used to put new buffers onto the free-list. Just make sure the "size" field of the <a class="el" href="struct_g_data_buffer.html" title="A Data Buffer Queue. ">GDataBuffer</a> structure has been filled in first.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:ga59509aa7155577e1d58eebbea2291736"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferRelease</b> (<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *pd)</td></tr>
<tr class="separator:ga59509aa7155577e1d58eebbea2291736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6231808c87d2d81e60c79af9932bf9a6"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferReleaseI</b> (<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *pd)</td></tr>
<tr class="separator:ga6231808c87d2d81e60c79af9932bf9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Pop() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Pop an item from the head of the queue (and remove it from the queue).</p>
<p>This is exactly the same as the Get operation above.</p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gaee90fcbacaf0ac34a161757c6652e7fa"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPop</b>(pqueue)&#160;&#160;&#160;gfxQueueASyncGet(pqueue)</td></tr>
<tr class="separator:gaee90fcbacaf0ac34a161757c6652e7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae699a42b89bbb8dc538e65f55e2ef845"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPopI</b>(pqueue)&#160;&#160;&#160;gfxQueueASyncGetI(pqueue)</td></tr>
<tr class="separator:gae699a42b89bbb8dc538e65f55e2ef845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffc540ea709decce125fce4e6b81ca7"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPop</b>(pqueue,  ms)&#160;&#160;&#160;gfxQueueGSyncGet(pqueue, ms)</td></tr>
<tr class="separator:ga0ffc540ea709decce125fce4e6b81ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ce5eefb3e834caa234a1f7c6f6f34f"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPop</b>(pqueue,  ms)&#160;&#160;&#160;gfxQueueFSyncGet(pqueue, ms)</td></tr>
<tr class="separator:ga30ce5eefb3e834caa234a1f7c6f6f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">isEmpty() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Is the queue empty?</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the queue is empty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:ga1feed3e5edeeb27c4698c9c3d9197410"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsEmpty</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga1feed3e5edeeb27c4698c9c3d9197410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de06f81ab58bd9103f5c2527eef8f2b"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsEmptyI</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga1de06f81ab58bd9103f5c2527eef8f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5011ce8f248319ce75d9620d7b2db6c9"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsEmpty</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga5011ce8f248319ce75d9620d7b2db6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17a79a893cb8a510dcb4b8d307e38e3"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsEmptyI</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:gaf17a79a893cb8a510dcb4b8d307e38e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5330584b2520e9635dba8ccd8e531d"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsEmpty</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga6c5330584b2520e9635dba8ccd8e531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb7691cabf2ee16dacd3825841b9ec4"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsEmptyI</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga8cb7691cabf2ee16dacd3825841b9ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Peek() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the first item from the head of the queue but do not remove it from the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no item is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call does not block. </dd>
<dd>
This can be used as the first call to iterate all the elements in the queue. </dd>
<dd>
As that item is still on the queue, it should be treated as read-only. It could also be removed from the queue at any time by another thread (thereby altering the queue item). </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:gae9b14a9595a6fde52bf315aae064a446"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPeek</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:gae9b14a9595a6fde52bf315aae064a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a27afba48e4f5ce24c436656be9225c"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPeekI</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:ga0a27afba48e4f5ce24c436656be9225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891611cb4b0851a063b77b6a32dfd933"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPeek</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:ga891611cb4b0851a063b77b6a32dfd933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8cd1f4a30554944b68540540d058ef"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPeekI</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:gafc8cd1f4a30554944b68540540d058ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab39171a70ef510be22f71de35c957c76"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPeek</b>(pqueue)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:gab39171a70ef510be22f71de35c957c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cfe5d247ebae89de2a108cb46abaf6d"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPeekI</b>(pqueue)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:ga4cfe5d247ebae89de2a108cb46abaf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Next() Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the next item in the queue (but do not remove it from the queue).</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no item is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>The previous item in the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call does not block. </dd>
<dd>
This can be used as subsequent calls to iterate all the elements in the queue. </dd>
<dd>
As that item is still on the queue, it should be treated as read-only. It could also be removed from the queue at any time by another thread (thereby altering the queue item). </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</div></td></tr>
<tr class="memitem:ga0d88bd563a6b22d593622d8e3a6f636b"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncNext</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga0d88bd563a6b22d593622d8e3a6f636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e4ded33f03d5e62d75c7393988a557"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncNextI</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga62e4ded33f03d5e62d75c7393988a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e3fad66c11f8708bb0e12ad523aec8"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncNext</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga20e3fad66c11f8708bb0e12ad523aec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0167aa7b8a3340bf629c4af33ef614c0"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncNextI</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga0167aa7b8a3340bf629c4af33ef614c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d9b27b69f4021bcfa926f4c662cc20"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncNext</b>(pitem)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga73d9b27b69f4021bcfa926f4c662cc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250336b7fa90bbd8492f6b622cecfb28"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncNextI</b>(pitem)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga250336b7fa90bbd8492f6b622cecfb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga971d6f9cffcb78ff22b93c825d8aeb8c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_g_data_buffer.html">GDataBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga971d6f9cffcb78ff22b93c825d8aeb8c">GDataBuffer</a></td></tr>
<tr class="memdesc:ga971d6f9cffcb78ff22b93c825d8aeb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Data Buffer Queue.  <a href="group___g_q_u_e_u_e.html#ga971d6f9cffcb78ff22b93c825d8aeb8c">More...</a><br /></td></tr>
<tr class="separator:ga971d6f9cffcb78ff22b93c825d8aeb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gae485b5c37fcf8e479764e92c7e599902"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gae485b5c37fcf8e479764e92c7e599902">gfxQueueASyncItem</a></td></tr>
<tr class="memdesc:gae485b5c37fcf8e479764e92c7e599902"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue item.  <a href="group___g_q_u_e_u_e.html#gae485b5c37fcf8e479764e92c7e599902">More...</a><br /></td></tr>
<tr class="separator:gae485b5c37fcf8e479764e92c7e599902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga0274bbb59822547a490bcc8331ba7f1a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga0274bbb59822547a490bcc8331ba7f1a">gfxQueueASync</a></td></tr>
<tr class="memdesc:ga0274bbb59822547a490bcc8331ba7f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue.  <a href="group___g_q_u_e_u_e.html#ga0274bbb59822547a490bcc8331ba7f1a">More...</a><br /></td></tr>
<tr class="separator:ga0274bbb59822547a490bcc8331ba7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Deinitialisation functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9b7471458846c73f58325bc4e3387cb3"></a>De-Initialise a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga821d305a30adb32c5777913881c284fb"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncDeinit</b>(pqueue)</td></tr>
<tr class="separator:ga821d305a30adb32c5777913881c284fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056cfe797e7abff86830cbf0627e0b33"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncDeinit</b> (gfxQueueGSync *pqueue)</td></tr>
<tr class="separator:ga056cfe797e7abff86830cbf0627e0b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce8a88f611c28f942a51525d54f4217"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncDeinit</b> (gfxQueueFSync *pqueue)</td></tr>
<tr class="separator:ga8ce8a88f611c28f942a51525d54f4217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e1cf65e5caa5b20be391e0669541b825.html">cygdrive</a></li><li class="navelem"><a class="el" href="dir_7a9e18c03596d8465cf006c2a17f1e00.html">c</a></li><li class="navelem"><a class="el" href="dir_131bf6f7fbe39855aa171f90c63ba4bc.html">Users</a></li><li class="navelem"><a class="el" href="dir_c5ff1c6b8799d099713fa2d2284b2e80.html">joel</a></li><li class="navelem"><a class="el" href="dir_c266a1537722fb7d9b8c2e3c8eb521a7.html">Documents</a></li><li class="navelem"><a class="el" href="dir_436e6450bd9aa2a776705cf9af09573b.html">projects</a></li><li class="navelem"><a class="el" href="dir_e6b656436f826952e95b4c2334f3c455.html">resources</a></li><li class="navelem"><a class="el" href="dir_46285512daa87cfd87dcd5bfe734839d.html">ugfx</a></li><li class="navelem"><a class="el" href="dir_83fd4c4d05c53161474a45fa79fcdafa.html">src</a></li><li class="navelem"><a class="el" href="dir_e447c15b2bfc1c4f68cb148f96a1a22c.html">gqueue</a></li><li class="navelem"><a class="el" href="gqueue_8h.html">gqueue.h</a></li>
    <li class="footer">Generated on Thu Jul 28 2016 14:53:55 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>

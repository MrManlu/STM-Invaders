<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GADC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ugfx_logo_doxygen.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">version 2.6</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___g_a_d_c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">GADC</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Module to abstract the very variable ADC interfaces of the underlying systems. </p>
<p>The reason why ChibiOS/GFX has it's own ADC abstraction is because the Chibi-OS drivers are very CPU specific and do not provide a way across all hardware platforms to create periodic ADC conversions. There are also issues with devices with different characteristics or periodic requirements on the same ADC device (but different channels). This layer attempts to solve these problems to provide a architecture neutral API. It also provides extra features such as multi-buffer chaining for high speed ADC sources. It provides one high speed virtual ADC device (eg a microphone) and numerous low speed (less than 100Hz) virtual ADC devices (eg dials, temperature sensors etc). The high speed device has timer based polling to ensure exact conversion periods and a buffer management system. The low speed devices are assumed to be non-critical timing devices and do not have any buffer management. Note that while only one high speed device has been provided it can be used to read multiple physical ADC channels on the one physical ADC device. All callback routines are thread based unlike the Chibi-OS interrupt based routines. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_event_a_d_c__t.html">GEventADC_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The High Speed ADC event structure.  <a href="struct_g_event_a_d_c__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___g_a_d_c___driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c___driver.html">Driver</a></td></tr>
<tr class="memdesc:group___g_a_d_c___driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver interface for the GADC module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf6ace2ac7f7c5a2d6cff4c2a409568d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#gaaf6ace2ac7f7c5a2d6cff4c2a409568d">gadcHighSpeedInit</a> (uint32_t physdev, uint32_t frequency)</td></tr>
<tr class="memdesc:gaaf6ace2ac7f7c5a2d6cff4c2a409568d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the high speed ADC.  <a href="#gaaf6ace2ac7f7c5a2d6cff4c2a409568d">More...</a><br /></td></tr>
<tr class="separator:gaaf6ace2ac7f7c5a2d6cff4c2a409568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b277d57793e1212ab0455d47a5fb2ef"><td class="memItemLeft" align="right" valign="top">GSourceHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga6b277d57793e1212ab0455d47a5fb2ef">gadcHighSpeedGetSource</a> (void)</td></tr>
<tr class="memdesc:ga6b277d57793e1212ab0455d47a5fb2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on sending results to the GEVENT sub-system.  <a href="#ga6b277d57793e1212ab0455d47a5fb2ef">More...</a><br /></td></tr>
<tr class="separator:ga6b277d57793e1212ab0455d47a5fb2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43124245b3bbaa16e4f6e7f4339a0239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga43124245b3bbaa16e4f6e7f4339a0239">gadcHighSpeedSetISRCallback</a> (<a class="el" href="group___g_a_d_c.html#gaf6a74ccae4e253aac58571f1bfcf9dd1">GADCISRCallbackFunction</a> isrfn)</td></tr>
<tr class="memdesc:ga43124245b3bbaa16e4f6e7f4339a0239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow retrieving of results from the high speed ADC using an ISR callback.  <a href="#ga43124245b3bbaa16e4f6e7f4339a0239">More...</a><br /></td></tr>
<tr class="separator:ga43124245b3bbaa16e4f6e7f4339a0239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9abbbe4766baae5030952887d81393f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#gaf9abbbe4766baae5030952887d81393f">gadcHighSpeedStart</a> (void)</td></tr>
<tr class="memdesc:gaf9abbbe4766baae5030952887d81393f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the high speed ADC conversions.  <a href="#gaf9abbbe4766baae5030952887d81393f">More...</a><br /></td></tr>
<tr class="separator:gaf9abbbe4766baae5030952887d81393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8589721565474bf2adeae2957ce966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga7c8589721565474bf2adeae2957ce966">gadcHighSpeedStop</a> (void)</td></tr>
<tr class="memdesc:ga7c8589721565474bf2adeae2957ce966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the high speed ADC conversions.  <a href="#ga7c8589721565474bf2adeae2957ce966">More...</a><br /></td></tr>
<tr class="separator:ga7c8589721565474bf2adeae2957ce966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga6a71e8f6a5d66e92824ccf5ccdfb4f3c">gadcLowSpeedGet</a> (uint32_t physdev, adcsample_t *buffer)</td></tr>
<tr class="memdesc:ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a single low speed ADC conversion.  <a href="#ga6a71e8f6a5d66e92824ccf5ccdfb4f3c">More...</a><br /></td></tr>
<tr class="separator:ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072e25bf1fc9b176da8b164d5feed119"><td class="memItemLeft" align="right" valign="top">bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga072e25bf1fc9b176da8b164d5feed119">gadcLowSpeedStart</a> (uint32_t physdev, adcsample_t *buffer, <a class="el" href="group___g_a_d_c.html#ga1be63f6f42e46a020e15cab476e79792">GADCCallbackFunction</a> fn, void *param)</td></tr>
<tr class="memdesc:ga072e25bf1fc9b176da8b164d5feed119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a low speed ADC conversion with callback (in a thread context)  <a href="#ga072e25bf1fc9b176da8b164d5feed119">More...</a><br /></td></tr>
<tr class="separator:ga072e25bf1fc9b176da8b164d5feed119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8fd271f26d0327bc4e90ea7b044870b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_g_event_a_d_c__t.html">GEventADC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#gaf8fd271f26d0327bc4e90ea7b044870b">GEventADC</a></td></tr>
<tr class="memdesc:gaf8fd271f26d0327bc4e90ea7b044870b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The High Speed ADC event structure.  <a href="#gaf8fd271f26d0327bc4e90ea7b044870b">More...</a><br /></td></tr>
<tr class="separator:gaf8fd271f26d0327bc4e90ea7b044870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8f7cd40768cf7ac4faec42158ea5ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga7c8f7cd40768cf7ac4faec42158ea5ef">gadcHighSpeedGetData</a> (delaytime_t ms)</td></tr>
<tr class="memdesc:ga7c8f7cd40768cf7ac4faec42158ea5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a filled buffer from the ADC.  <a href="#ga7c8f7cd40768cf7ac4faec42158ea5ef">More...</a><br /></td></tr>
<tr class="separator:ga7c8f7cd40768cf7ac4faec42158ea5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
GADC Optional Sizing Parameters</h2></td></tr>
<tr class="memitem:ga3b75b30a27e5afbcdac157b5627dba3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga3b75b30a27e5afbcdac157b5627dba3b">GADC_MAX_HIGH_SPEED_SAMPLERATE</a>&#160;&#160;&#160;44000</td></tr>
<tr class="memdesc:ga3b75b30a27e5afbcdac157b5627dba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum GADC sample rate.  <a href="#ga3b75b30a27e5afbcdac157b5627dba3b">More...</a><br /></td></tr>
<tr class="separator:ga3b75b30a27e5afbcdac157b5627dba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1be63f6f42e46a020e15cab476e79792"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga1be63f6f42e46a020e15cab476e79792">GADCCallbackFunction</a>) (adcsample_t *buffer, void *param)</td></tr>
<tr class="memdesc:ga1be63f6f42e46a020e15cab476e79792"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function (executed in a thread context) for a low speed conversion.  <a href="#ga1be63f6f42e46a020e15cab476e79792">More...</a><br /></td></tr>
<tr class="separator:ga1be63f6f42e46a020e15cab476e79792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a74ccae4e253aac58571f1bfcf9dd1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#gaf6a74ccae4e253aac58571f1bfcf9dd1">GADCISRCallbackFunction</a>) (void)</td></tr>
<tr class="memdesc:gaf6a74ccae4e253aac58571f1bfcf9dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function (executed in an ISR context) for a high speed conversion.  <a href="#gaf6a74ccae4e253aac58571f1bfcf9dd1">More...</a><br /></td></tr>
<tr class="separator:gaf6a74ccae4e253aac58571f1bfcf9dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7c8f7cd40768cf7ac4faec42158ea5ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_g_data_buffer.html">GDataBuffer</a>* gadcHighSpeedGetData </td>
          <td>(</td>
          <td class="paramtype">delaytime_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a filled buffer from the ADC. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_g_data_buffer.html" title="A Data Buffer Queue. ">GDataBuffer</a> pointer or NULL if the timeout is exceeded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maximum amount of time in milliseconds to wait for data if some is not currently available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After processing the data, your application must return the buffer to the free-list so that it can be used again. This can be done using <code>gfxBufferRelease()</code>. </dd>
<dd>
A buffer may be returned to the free-list before you have finished processing it provided you finish processing it before GADC re-uses it. This is useful when RAM usage is critical to reduce the number of buffers required. It works before the free list is a FIFO queue and therefore buffers are kept in the queue as long as possible before they are re-used. </dd>
<dd>
The function ending with "I" is the interrupt class function. </dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b277d57793e1212ab0455d47a5fb2ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSourceHandle gadcHighSpeedGetSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on sending results to the GEVENT sub-system. </p>
<p>Returns a GSourceHandle to listen for GEVENT_ADC events.</p>
<dl class="section note"><dt>Note</dt><dd>The high speed ADC will not use the GEVENT system unless this is called first. This saves processing time if the application does not want to use the GEVENT sub-system for the high speed ADC. Once turned on it can only be turned off by calling <code><a class="el" href="group___g_a_d_c.html#gaaf6ace2ac7f7c5a2d6cff4c2a409568d" title="Initialise the high speed ADC. ">gadcHighSpeedInit()</a></code> again. </dd>
<dd>
The high speed ADC is capable of signalling via this method, an ISR callback and a binary semaphore at the same time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GSourceHandle</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf6ace2ac7f7c5a2d6cff4c2a409568d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>physdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the high speed ADC. </p>
<p>Initialises but does not start the conversions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physdev</td><td>A value passed to describe which physical ADC devices/channels to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frequency</td><td>The frequency to create ADC conversions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the high speed ADC is running it will be stopped. The Event subsystem is disconnected from the high speed ADC and any binary semaphore event is forgotten. </dd>
<dd>
ChibiOS ONLY: Due to a bug in ChibiOS each buffer on the free-list must contain an even number of samples and for multi-channel devices it must hold a number of samples that is evenly divisible by 2 times the number of active channels. </dd>
<dd>
The physdev parameter may be used to turn on more than one ADC channel. Each channel is then interleaved into the provided buffer. Make sure your buffers all hold a number of samples evenly divisible by the number of active channels. As an example, if physdev turns on 2 devices then the buffer contains alternate device samples and the buffer must contain multiples of 2 samples. The exact meaning of physdev is hardware dependent. </dd>
<dd>
While the high speed ADC is running, low speed conversions can only occur at the frequency of the high speed events. Thus if high speed events are being created at 50Hz (eg 100 samples/buffer, frequency = 5kHz) then the maximum frequency for low speed conversions will be 50Hz. </dd>
<dd>
Only a single sample format is supported - that provided by the GADC driver. That sample format applies to both high speed and low speed sampling.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43124245b3bbaa16e4f6e7f4339a0239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedSetISRCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___g_a_d_c.html#gaf6a74ccae4e253aac58571f1bfcf9dd1">GADCISRCallbackFunction</a>&#160;</td>
          <td class="paramname"><em>isrfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow retrieving of results from the high speed ADC using an ISR callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">isrfn</td><td>The callback function (called in an ISR context).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Passing a NULL for isrfn will turn off signalling via this method as will calling <code><a class="el" href="group___g_a_d_c.html#gaaf6ace2ac7f7c5a2d6cff4c2a409568d" title="Initialise the high speed ADC. ">gadcHighSpeedInit()</a></code>. </dd>
<dd>
The high speed ADC is capable of signalling via this method, a blocked thread and the GEVENT sub-system at the same time.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9abbbe4766baae5030952887d81393f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the high speed ADC conversions. </p>
<dl class="section pre"><dt>Precondition</dt><dd>It must have been initialised first with <code><a class="el" href="group___g_a_d_c.html#gaaf6ace2ac7f7c5a2d6cff4c2a409568d" title="Initialise the high speed ADC. ">gadcHighSpeedInit()</a></code> </dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c8589721565474bf2adeae2957ce966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedStop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the high speed ADC conversions. </p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcLowSpeedGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>physdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adcsample_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a single low speed ADC conversion. </p>
<p>Blocks until the conversion is complete </p><dl class="section pre"><dt>Precondition</dt><dd>This should not be called from within a GTimer callback as this routine blocks until the conversion is ready.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physdev</td><td>A value passed to describe which physical ADC devices/channels to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The static buffer to put the ADC samples into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This may take a while to complete if the high speed ADC is running as the conversion is interleaved with the high speed ADC conversions on a buffer completion. </dd>
<dd>
The result buffer must be large enough to store one sample per device described by the 'physdev' parameter. </dd>
<dd>
Specifying more than one device in physdev is possible but discouraged as the calculations to ensure the high speed ADC correctness will be incorrect. Symptoms from over-running the high speed ADC include high speed device stalling or samples being lost.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<a class="anchor" id="ga072e25bf1fc9b176da8b164d5feed119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool_t gadcLowSpeedStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>physdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adcsample_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_a_d_c.html#ga1be63f6f42e46a020e15cab476e79792">GADCCallbackFunction</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a low speed ADC conversion with callback (in a thread context) </p>
<p>Returns FALSE if internal memory allocation fails</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physdev</td><td>A value passed to describe which physical ADC devices/channels to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The static buffer to put the ADC samples into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>The callback function to call when the conversion is complete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>A parameter to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if no free low speed ADC slots.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This may be safely called from within a GTimer callback. </dd>
<dd>
The callback may take a while to occur if the high speed ADC is running as the conversion is interleaved with the high speed ADC conversions on a buffer completion. </dd>
<dd>
The result buffer must be large enough to store one sample per device described by the 'physdev' parameter. </dd>
<dd>
Specifying more than one device in physdev is possible but discouraged as the calculations to ensure the high speed ADC correctness will be incorrect. Symptoms from over-running the high speed ADC include high speed samples being lost.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga3b75b30a27e5afbcdac157b5627dba3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GADC_MAX_HIGH_SPEED_SAMPLERATE&#160;&#160;&#160;44000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum GADC sample rate. </p>
<p>Defaults to 44000 </p><dl class="section note"><dt>Note</dt><dd>This value must be less than half the maximum sample rate allowed by the CPU. This is to ensure there is time between high speed samples to perform low speed device sampling. </dd></dl>

<p>Definition at line <a class="el" href="gadc__options_8h_source.html#l00037">37</a> of file <a class="el" href="gadc__options_8h_source.html">gadc_options.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1be63f6f42e46a020e15cab476e79792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* GADCCallbackFunction) (adcsample_t *buffer, void *param)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function (executed in a thread context) for a low speed conversion. </p>

<p>Definition at line <a class="el" href="gadc_8h_source.html#l00086">86</a> of file <a class="el" href="gadc_8h_source.html">gadc.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6a74ccae4e253aac58571f1bfcf9dd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* GADCISRCallbackFunction) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function (executed in an ISR context) for a high speed conversion. </p>

<p>Definition at line <a class="el" href="gadc_8h_source.html#l00091">91</a> of file <a class="el" href="gadc_8h_source.html">gadc.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8fd271f26d0327bc4e90ea7b044870b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_g_event_a_d_c__t.html">GEventADC_t</a>  <a class="el" href="group___g_a_d_c.html#gaf8fd271f26d0327bc4e90ea7b044870b">GEventADC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The High Speed ADC event structure. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jul 28 2016 14:53:57 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GQUEUE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ugfx_logo_doxygen.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">version 2.6</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___g_q_u_e_u_e.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">GQUEUE</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Module which provides queue management (only internally used) </p>
<p>There are 3 types of queues: </p><ul>
<li>
<b>Asynchronous Queues (ASync) </b> - Queue operations never block </li>
<li>
<b>Get Synchronous Queues (GSync) </b> - Queue Get operations block until something is placed in the Queue </li>
<li>
<b>Put Synchronous Queues (PSync)</b> - Queue Put operations block until the element is removed from the Queue </li>
<li>
<b>Fully Synchronous Queues (FSync)</b> - Queue GET and Put operations block </li>
</ul>
<p>We need 4 types of queues even though fully synchronous queues support all operations including asynchronous operations because fully synchronous queues have the highest storage requirements. The other queue types are optimizations. Efficiency IS important to use (particularly RAM efficiency). In practice we only implement ASync, GSync and FSync queues as PSync queues are of dubious value. <br />
 We also define <a class="el" href="struct_g_data_buffer.html" title="A Data Buffer Queue. ">GDataBuffer</a> which is a data buffer that supports being queued. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue item.  <a href="structgfx_queue_a_sync_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue.  <a href="structgfx_queue_a_sync.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_data_buffer.html">GDataBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Data Buffer Queue.  <a href="struct_g_data_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae485b5c37fcf8e479764e92c7e599902"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gae485b5c37fcf8e479764e92c7e599902">gfxQueueASyncItem</a></td></tr>
<tr class="memdesc:gae485b5c37fcf8e479764e92c7e599902"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue item.  <a href="#gae485b5c37fcf8e479764e92c7e599902">More...</a><br /></td></tr>
<tr class="separator:gae485b5c37fcf8e479764e92c7e599902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0274bbb59822547a490bcc8331ba7f1a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga0274bbb59822547a490bcc8331ba7f1a">gfxQueueASync</a></td></tr>
<tr class="memdesc:ga0274bbb59822547a490bcc8331ba7f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue.  <a href="#ga0274bbb59822547a490bcc8331ba7f1a">More...</a><br /></td></tr>
<tr class="separator:ga0274bbb59822547a490bcc8331ba7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialisation functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp748928d8748dd59a9b39a3c9b1740f9e"></a>Initialise a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Whilst queues are normally FIFO, a GFX queue also supports push and pop operations. A pop operation is the same as normal get from the queue but a push places the item at the head of the queue instead of the tail (as a put would).</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga03a187ba5739f36530498f333145a913"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03a187ba5739f36530498f333145a913"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncInit</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="separator:ga03a187ba5739f36530498f333145a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b977df2892d59b7ffa0c63c629d6dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga14b977df2892d59b7ffa0c63c629d6dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncInit</b> (gfxQueueGSync *pqueue)</td></tr>
<tr class="separator:ga14b977df2892d59b7ffa0c63c629d6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4651f6cb9c071ae66ac0a7363f1dce9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4651f6cb9c071ae66ac0a7363f1dce9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncInit</b> (gfxQueueFSync *pqueue)</td></tr>
<tr class="separator:ga4651f6cb9c071ae66ac0a7363f1dce9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Deinitialisation functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9b7471458846c73f58325bc4e3387cb3"></a>De-Initialise a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga056cfe797e7abff86830cbf0627e0b33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga056cfe797e7abff86830cbf0627e0b33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncDeinit</b> (gfxQueueGSync *pqueue)</td></tr>
<tr class="separator:ga056cfe797e7abff86830cbf0627e0b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce8a88f611c28f942a51525d54f4217"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ce8a88f611c28f942a51525d54f4217"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncDeinit</b> (gfxQueueFSync *pqueue)</td></tr>
<tr class="separator:ga8ce8a88f611c28f942a51525d54f4217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga821d305a30adb32c5777913881c284fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga821d305a30adb32c5777913881c284fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncDeinit</b>(pqueue)</td></tr>
<tr class="separator:ga821d305a30adb32c5777913881c284fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Get() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf58941ca20e8c400c6848ec1a1aa5f73"></a>Get an item from the head of the queue (and remove it from the queue).</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if the timeout expires before an item is available</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item. For ASync queues this parameter is not specified as TIME_IMMEDIATE is assumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga83033845f1cc4e859293f759d184ef24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83033845f1cc4e859293f759d184ef24"></a>
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncGet</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="separator:ga83033845f1cc4e859293f759d184ef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2e0b2046bd34e2bdd77a7c178d0850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e2e0b2046bd34e2bdd77a7c178d0850"></a>
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncGetI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="separator:ga6e2e0b2046bd34e2bdd77a7c178d0850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb1a0982330c88386890f82cb94f714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaebb1a0982330c88386890f82cb94f714"></a>
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncGet</b> (gfxQueueGSync *pqueue, delaytime_t ms)</td></tr>
<tr class="separator:gaebb1a0982330c88386890f82cb94f714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae85084f1fd6fa64dd0433ed2d24957db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae85084f1fd6fa64dd0433ed2d24957db"></a>
<a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncGetI</b> (gfxQueueGSync *pqueue)</td></tr>
<tr class="separator:gae85084f1fd6fa64dd0433ed2d24957db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee6d919291966b32b3b89682e09913f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafee6d919291966b32b3b89682e09913f"></a>
gfxQueueFSyncItem *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncGet</b> (gfxQueueFSync *pqueue, delaytime_t ms)</td></tr>
<tr class="separator:gafee6d919291966b32b3b89682e09913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Put() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp65e9fd95ca1bca51d95e470c31886039"></a>Put an item on the end of the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be removed from the queue (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga001f294beec7a5a93bb386caded77b17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga001f294beec7a5a93bb386caded77b17"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPut</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga001f294beec7a5a93bb386caded77b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077fa0788a1c9e77de24b653b00bd822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga077fa0788a1c9e77de24b653b00bd822"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPutI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga077fa0788a1c9e77de24b653b00bd822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a1e2048cbb5d46ea00b97b62016f7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29a1e2048cbb5d46ea00b97b62016f7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPut</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga29a1e2048cbb5d46ea00b97b62016f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c698db99c16e5e17254e4bcd8686f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga68c698db99c16e5e17254e4bcd8686f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPutI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga68c698db99c16e5e17254e4bcd8686f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e053eba0ca203f98896e3049eb6c34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga99e053eba0ca203f98896e3049eb6c34"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPut</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, delaytime_t ms)</td></tr>
<tr class="separator:ga99e053eba0ca203f98896e3049eb6c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Pop() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0d71680e7966fede82ebd39af92284a3"></a>Pop an item from the head of the queue (and remove it from the queue).</p>
<p>This is exactly the same as the Get operation above.</p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gaee90fcbacaf0ac34a161757c6652e7fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee90fcbacaf0ac34a161757c6652e7fa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPop</b>(pqueue)&#160;&#160;&#160;gfxQueueASyncGet(pqueue)</td></tr>
<tr class="separator:gaee90fcbacaf0ac34a161757c6652e7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae699a42b89bbb8dc538e65f55e2ef845"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae699a42b89bbb8dc538e65f55e2ef845"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPopI</b>(pqueue)&#160;&#160;&#160;gfxQueueASyncGetI(pqueue)</td></tr>
<tr class="separator:gae699a42b89bbb8dc538e65f55e2ef845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffc540ea709decce125fce4e6b81ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ffc540ea709decce125fce4e6b81ca7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPop</b>(pqueue,  ms)&#160;&#160;&#160;gfxQueueGSyncGet(pqueue, ms)</td></tr>
<tr class="separator:ga0ffc540ea709decce125fce4e6b81ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ce5eefb3e834caa234a1f7c6f6f34f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga30ce5eefb3e834caa234a1f7c6f6f34f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPop</b>(pqueue,  ms)&#160;&#160;&#160;gfxQueueFSyncGet(pqueue, ms)</td></tr>
<tr class="separator:ga30ce5eefb3e834caa234a1f7c6f6f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Push() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5d1b10a7959f73eb9fedf67803a0136c"></a>Push an item into the start of the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be popped (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga89673f2d1210c10ff00ef6c4b5312900"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89673f2d1210c10ff00ef6c4b5312900"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPush</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga89673f2d1210c10ff00ef6c4b5312900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa023f02f86039a81e2db96e777e3a991"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa023f02f86039a81e2db96e777e3a991"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPushI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gaa023f02f86039a81e2db96e777e3a991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2415bb7b6e06dd5060133d306d5321"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a2415bb7b6e06dd5060133d306d5321"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPush</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga5a2415bb7b6e06dd5060133d306d5321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e545ee12d1caf3324029f196e2d21f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e545ee12d1caf3324029f196e2d21f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPushI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga4e545ee12d1caf3324029f196e2d21f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912bddea2951b911d67ee658ae6f5dea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga912bddea2951b911d67ee658ae6f5dea"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPush</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, delaytime_t ms)</td></tr>
<tr class="separator:ga912bddea2951b911d67ee658ae6f5dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Insert() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6f1e26267247d00a0d03271e0962e971"></a>Insert an item on the queue after the specified item.</p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pafter</td><td>A pointer to the queue item this new item must be inserted after. If NULL or pafter can't be found in the queue, it puts the new item at the end of the queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be removed from the queue (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gae63e497a256d0d1283ac7827fa3eb310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae63e497a256d0d1283ac7827fa3eb310"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncInsert</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:gae63e497a256d0d1283ac7827fa3eb310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45aadd51433be0253014497d94d50ff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga45aadd51433be0253014497d94d50ff5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncInsertI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:ga45aadd51433be0253014497d94d50ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5ca470f46aec8cf41132a1e7374f1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a5ca470f46aec8cf41132a1e7374f1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncInsert</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:ga0a5ca470f46aec8cf41132a1e7374f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d56974a55fd28495b2aefeaa318cd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00d56974a55fd28495b2aefeaa318cd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncInsertI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter)</td></tr>
<tr class="separator:ga00d56974a55fd28495b2aefeaa318cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b913366908bb4cf5d0853da6fec817"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf2b913366908bb4cf5d0853da6fec817"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncInsert</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pafter, delaytime_t ms)</td></tr>
<tr class="separator:gaf2b913366908bb4cf5d0853da6fec817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Remove() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3a7abab4715fb40a789450d9258dc07f"></a>Remove an item from the queue.</p>
<dl class="section note"><dt>Note</dt><dd>Removes the specified item from the queue where-ever it is in the queue</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the item isn't in the queue the routine just returns. </dd>
<dd>
If a process is waiting on the Put/Push operation for the item, that process will be signaled. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gacab8013b870b58e1a8a082fac8d06e1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacab8013b870b58e1a8a082fac8d06e1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncRemove</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gacab8013b870b58e1a8a082fac8d06e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca02e905e708a7ad69471d97ca79d8b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca02e905e708a7ad69471d97ca79d8b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncRemoveI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gaca02e905e708a7ad69471d97ca79d8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d1a6b2b8f8e81801cd2e36405307fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25d1a6b2b8f8e81801cd2e36405307fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncRemove</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga25d1a6b2b8f8e81801cd2e36405307fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4b7e2dabbf7b1c4486fc5155c0bfaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaef4b7e2dabbf7b1c4486fc5155c0bfaa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncRemoveI</b> (gfxQueueGSync *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:gaef4b7e2dabbf7b1c4486fc5155c0bfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a32b12810379e7282198ae224633b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74a32b12810379e7282198ae224633b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncRemove</b> (gfxQueueFSync *pqueue, gfxQueueFSyncItem *pitem)</td></tr>
<tr class="separator:ga74a32b12810379e7282198ae224633b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
isEmpty() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrped44509df389178c665ead80dcc79385"></a>Is the queue empty?</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the queue is empty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga1feed3e5edeeb27c4698c9c3d9197410"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1feed3e5edeeb27c4698c9c3d9197410"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsEmpty</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga1feed3e5edeeb27c4698c9c3d9197410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de06f81ab58bd9103f5c2527eef8f2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1de06f81ab58bd9103f5c2527eef8f2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsEmptyI</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga1de06f81ab58bd9103f5c2527eef8f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5011ce8f248319ce75d9620d7b2db6c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5011ce8f248319ce75d9620d7b2db6c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsEmpty</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga5011ce8f248319ce75d9620d7b2db6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17a79a893cb8a510dcb4b8d307e38e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf17a79a893cb8a510dcb4b8d307e38e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsEmptyI</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:gaf17a79a893cb8a510dcb4b8d307e38e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5330584b2520e9635dba8ccd8e531d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c5330584b2520e9635dba8ccd8e531d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsEmpty</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga6c5330584b2520e9635dba8ccd8e531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb7691cabf2ee16dacd3825841b9ec4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8cb7691cabf2ee16dacd3825841b9ec4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsEmptyI</b>(pqueue)&#160;&#160;&#160;((pqueue)-&gt;head == 0)</td></tr>
<tr class="separator:ga8cb7691cabf2ee16dacd3825841b9ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
IsInQueue() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5133ab97f27c09d4661b84f56d6eddb4"></a>Is an item in the queue?</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the item is in the queue?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation may be expensive. </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gae5402e7c7e959c59230bdc2650366089"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5402e7c7e959c59230bdc2650366089"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsIn</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:gae5402e7c7e959c59230bdc2650366089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08afeb3550f1104ae87324e9b50bf96d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08afeb3550f1104ae87324e9b50bf96d"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncIsInI</b> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="separator:ga08afeb3550f1104ae87324e9b50bf96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5813e6e864d2d81ffa181f43f7fe961a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5813e6e864d2d81ffa181f43f7fe961a"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsIn</b> (gfxQueueGSync *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga5813e6e864d2d81ffa181f43f7fe961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08147f2ad13a0e255a9a43c385274535"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08147f2ad13a0e255a9a43c385274535"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncIsInI</b> (gfxQueueGSync *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *pitem)</td></tr>
<tr class="separator:ga08147f2ad13a0e255a9a43c385274535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8557b49663b1020e119afa6ba9684f4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8557b49663b1020e119afa6ba9684f4a"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsIn</b> (gfxQueueFSync *pqueue, const gfxQueueFSyncItem *pitem)</td></tr>
<tr class="separator:ga8557b49663b1020e119afa6ba9684f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5c3b9170965008ff3cd15a9aa862fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb5c3b9170965008ff3cd15a9aa862fc"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncIsInI</b> (gfxQueueFSync *pqueue, const gfxQueueFSyncItem *pitem)</td></tr>
<tr class="separator:gafb5c3b9170965008ff3cd15a9aa862fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Peek() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp62e4c9a3b45ea0c141d975eb1afdd77d"></a>Get the first item from the head of the queue but do not remove it from the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no item is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call does not block. </dd>
<dd>
This can be used as the first call to iterate all the elements in the queue. </dd>
<dd>
As that item is still on the queue, it should be treated as read-only. It could also be removed from the queue at any time by another thread (thereby altering the queue item). </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gae9b14a9595a6fde52bf315aae064a446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9b14a9595a6fde52bf315aae064a446"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPeek</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:gae9b14a9595a6fde52bf315aae064a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a27afba48e4f5ce24c436656be9225c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a27afba48e4f5ce24c436656be9225c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncPeekI</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:ga0a27afba48e4f5ce24c436656be9225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891611cb4b0851a063b77b6a32dfd933"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga891611cb4b0851a063b77b6a32dfd933"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPeek</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:ga891611cb4b0851a063b77b6a32dfd933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8cd1f4a30554944b68540540d058ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc8cd1f4a30554944b68540540d058ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncPeekI</b>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:gafc8cd1f4a30554944b68540540d058ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab39171a70ef510be22f71de35c957c76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab39171a70ef510be22f71de35c957c76"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPeek</b>(pqueue)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:gab39171a70ef510be22f71de35c957c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cfe5d247ebae89de2a108cb46abaf6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4cfe5d247ebae89de2a108cb46abaf6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncPeekI</b>(pqueue)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pqueue)-&gt;head))</td></tr>
<tr class="separator:ga4cfe5d247ebae89de2a108cb46abaf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Next() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7c8ff9dbbf37768c13b577d7510ba4b5"></a>Get the next item in the queue (but do not remove it from the queue).</p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no item is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>The previous item in the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call does not block. </dd>
<dd>
This can be used as subsequent calls to iterate all the elements in the queue. </dd>
<dd>
As that item is still on the queue, it should be treated as read-only. It could also be removed from the queue at any time by another thread (thereby altering the queue item). </dd>
<dd>
The routines ending in "I" are interrupt/system/iclass level routines.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga0d88bd563a6b22d593622d8e3a6f636b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0d88bd563a6b22d593622d8e3a6f636b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncNext</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga0d88bd563a6b22d593622d8e3a6f636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e4ded33f03d5e62d75c7393988a557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62e4ded33f03d5e62d75c7393988a557"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueASyncNextI</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga62e4ded33f03d5e62d75c7393988a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e3fad66c11f8708bb0e12ad523aec8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga20e3fad66c11f8708bb0e12ad523aec8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncNext</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga20e3fad66c11f8708bb0e12ad523aec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0167aa7b8a3340bf629c4af33ef614c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0167aa7b8a3340bf629c4af33ef614c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueGSyncNextI</b>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueGSyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga0167aa7b8a3340bf629c4af33ef614c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d9b27b69f4021bcfa926f4c662cc20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73d9b27b69f4021bcfa926f4c662cc20"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncNext</b>(pitem)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga73d9b27b69f4021bcfa926f4c662cc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250336b7fa90bbd8492f6b622cecfb28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga250336b7fa90bbd8492f6b622cecfb28"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>gfxQueueFSyncNextI</b>(pitem)&#160;&#160;&#160;((const gfxQueueFSyncItem *)((pitem)-&gt;next))</td></tr>
<tr class="separator:ga250336b7fa90bbd8492f6b622cecfb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
BufferAlloc() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8cac682fc77fa35190e0d53c0966d71c"></a>Allocate some buffers and put them on the free list</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE is it succeeded. FALSE on allocation failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number of buffers to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size (in bytes) of each buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gaabc0607342c286aa4f6781c5c9998c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabc0607342c286aa4f6781c5c9998c7f"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferAlloc</b> (unsigned num, size_t size)</td></tr>
<tr class="separator:gaabc0607342c286aa4f6781c5c9998c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
BufferIsAvailable() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5cdf8e976b99e51621d2d680559838ea"></a>Is there one or more buffers currently available on the free list</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if there are buffers in the free list</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gaa687b976d39b1327bc4383292dbf9890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa687b976d39b1327bc4383292dbf9890"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferIsAvailable</b> (void)</td></tr>
<tr class="separator:gaa687b976d39b1327bc4383292dbf9890"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
BufferGet() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6fd59cf26e8b07d0744fe5749f274eb8"></a>Get a buffer from the free list</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_g_data_buffer.html" title="A Data Buffer Queue. ">GDataBuffer</a> pointer or NULL if the timeout is exceeded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maximum amount of time in milliseconds to wait for a buffer if one is not available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:gaf854d111b80bc966929ce487d087c14f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf854d111b80bc966929ce487d087c14f"></a>
<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferGet</b> (delaytime_t ms)</td></tr>
<tr class="separator:gaf854d111b80bc966929ce487d087c14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568fed962fb35a16dc3ebbdeb829aba8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga568fed962fb35a16dc3ebbdeb829aba8"></a>
<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferGetI</b> (void)</td></tr>
<tr class="separator:ga568fed962fb35a16dc3ebbdeb829aba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
BufferRelease() Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8f4d73920f19f7e2cc02f79fd52c5948"></a>Release a buffer back to the free list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The buffer to put (back) on the free-list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call should be used to return any buffers that were taken from the free-list once they have been finished with. It can also be used to put new buffers onto the free-list. Just make sure the "size" field of the <a class="el" href="struct_g_data_buffer.html" title="A Data Buffer Queue. ">GDataBuffer</a> structure has been filled in first.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads. </dd></dl>
</td></tr>
<tr class="memitem:ga59509aa7155577e1d58eebbea2291736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59509aa7155577e1d58eebbea2291736"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferRelease</b> (<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *pd)</td></tr>
<tr class="separator:ga59509aa7155577e1d58eebbea2291736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6231808c87d2d81e60c79af9932bf9a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6231808c87d2d81e60c79af9932bf9a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gfxBufferReleaseI</b> (<a class="el" href="struct_g_data_buffer.html">GDataBuffer</a> *pd)</td></tr>
<tr class="separator:ga6231808c87d2d81e60c79af9932bf9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
GQUEUE Functions to include.</h2></td></tr>
<tr class="memitem:ga1833961a3b42ae3f87255b9c4c1c3737"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga1833961a3b42ae3f87255b9c4c1c3737">GQUEUE_NEED_ASYNC</a>&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td></tr>
<tr class="memdesc:ga1833961a3b42ae3f87255b9c4c1c3737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Asynchronous Queues.  <a href="#ga1833961a3b42ae3f87255b9c4c1c3737">More...</a><br /></td></tr>
<tr class="separator:ga1833961a3b42ae3f87255b9c4c1c3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5470bf32fe076ae47955b835bac6fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga3b5470bf32fe076ae47955b835bac6fc">GQUEUE_NEED_GSYNC</a>&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td></tr>
<tr class="memdesc:ga3b5470bf32fe076ae47955b835bac6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Get-Synchronous Queues.  <a href="#ga3b5470bf32fe076ae47955b835bac6fc">More...</a><br /></td></tr>
<tr class="separator:ga3b5470bf32fe076ae47955b835bac6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bbd123f626768795f0d80a2a6d47f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gaeb6bbd123f626768795f0d80a2a6d47f">GQUEUE_NEED_FSYNC</a>&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td></tr>
<tr class="memdesc:gaeb6bbd123f626768795f0d80a2a6d47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Fully Synchronous Queues.  <a href="#gaeb6bbd123f626768795f0d80a2a6d47f">More...</a><br /></td></tr>
<tr class="separator:gaeb6bbd123f626768795f0d80a2a6d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8dc56d94b7917ff26eacd3f251796f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga9d8dc56d94b7917ff26eacd3f251796f">GQUEUE_NEED_BUFFERS</a>&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td></tr>
<tr class="memdesc:ga9d8dc56d94b7917ff26eacd3f251796f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Queue-able Data Buffers.  <a href="#ga9d8dc56d94b7917ff26eacd3f251796f">More...</a><br /></td></tr>
<tr class="separator:ga9d8dc56d94b7917ff26eacd3f251796f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga971d6f9cffcb78ff22b93c825d8aeb8c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_g_data_buffer.html">GDataBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga971d6f9cffcb78ff22b93c825d8aeb8c">GDataBuffer</a></td></tr>
<tr class="memdesc:ga971d6f9cffcb78ff22b93c825d8aeb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Data Buffer Queue.  <a href="#ga971d6f9cffcb78ff22b93c825d8aeb8c">More...</a><br /></td></tr>
<tr class="separator:ga971d6f9cffcb78ff22b93c825d8aeb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga1833961a3b42ae3f87255b9c4c1c3737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GQUEUE_NEED_ASYNC&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Asynchronous Queues. </p>
<p>Defaults to FALSE </p>

<p>Definition at line <a class="el" href="gqueue__options_8h_source.html#l00028">28</a> of file <a class="el" href="gqueue__options_8h_source.html">gqueue_options.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d8dc56d94b7917ff26eacd3f251796f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GQUEUE_NEED_BUFFERS&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Queue-able Data Buffers. </p>

<p>Definition at line <a class="el" href="gqueue__options_8h_source.html#l00048">48</a> of file <a class="el" href="gqueue__options_8h_source.html">gqueue_options.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb6bbd123f626768795f0d80a2a6d47f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GQUEUE_NEED_FSYNC&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Fully Synchronous Queues. </p>
<p>Defaults to FALSE </p>

<p>Definition at line <a class="el" href="gqueue__options_8h_source.html#l00042">42</a> of file <a class="el" href="gqueue__options_8h_source.html">gqueue_options.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b5470bf32fe076ae47955b835bac6fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GQUEUE_NEED_GSYNC&#160;&#160;&#160;<a class="el" href="group___g_f_x.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Get-Synchronous Queues. </p>
<p>Defaults to FALSE </p>

<p>Definition at line <a class="el" href="gqueue__options_8h_source.html#l00035">35</a> of file <a class="el" href="gqueue__options_8h_source.html">gqueue_options.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga971d6f9cffcb78ff22b93c825d8aeb8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_g_data_buffer.html">GDataBuffer</a>  <a class="el" href="struct_g_data_buffer.html">GDataBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Data Buffer Queue. </p>
<dl class="section note"><dt>Note</dt><dd>This structure is followed immediately by the data itself. When allocating the buffers for the data put this structure at the beginning of the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0274bbb59822547a490bcc8331ba7f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a>  <a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A queue. </p>

</div>
</div>
<a class="anchor" id="gae485b5c37fcf8e479764e92c7e599902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a>  <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A queue item. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jul 28 2016 14:53:57 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
